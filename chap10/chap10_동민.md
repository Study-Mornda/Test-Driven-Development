# 10. 테스트 코드와 유지보수

테스트 코드는 그 자체로 코드이기 때문에 제품 코드와 동일하게 유지보수 대상이 된다. 테스트 코드를 유지보수하는 데 시간이 많이 들기 시작하면 점점 테스트 코드를 손보지 않아 아래와 같은 문제가 발생할 수 있다.

- 실패한 테스트가 새로 발생해도 $무감각$해진다. 테스트 실패 여부에 상관없이 빌드하고 배포하기 시작한다.
- 빌드를 통과시키기 위해 실패한 테스트를 주석 처리하고 실패한 테스트는 고치지 않는다.

이런 상환이 발생하면 테스트 코드는 가치를 잃기 시작한다.

실패한 테스트를 통과시키기 위해 많은 노력이 필요하면 → 점점 테스트 코드에서 멀어지고, TDD에서도 멀어진다. → 테스트 코드를 만들지 않으면, 테스트가 가능하지 않은 코드를 만들게 되고 → 다시 테스트 작성을 어렵게 만든다. → 테스트 코드가 줄어들면 수동으로 테스트하는 범위가 증가한다.

### 변수나 필드를 사용해서 기댓값 표현하지 않기

- 단언의 기대하는 값을 변수를 이용해서 구성한다.
- 객체를 생성할 때 사용한 값이 무엇인지 알아보기 위해 필드와 변수를 참조하지 않아도 된다.
- 단언할 때 사용한 값이 무엇인지 알기 위해 필드와 변수를 오갈 필요도 없다.

```bash
@Test
void dateFormat() {
	LocalDate date = LocalDate.of(1945, 8, 15); 
	String dateStr = formatDate(date);
	assertEquals("1945년 8월 15일", dateStr); // 복잡하지 않고 값도 명확하다
}
```

### 두 개 이상을 검증하지 않기

- 여러개의 검증 대상이 있다 테스트가 실패했을 때 두 가지 검증 대상 중 무엇이 실패했는지 확인하기 어렵다.
- 검증 대상이 명확하게 구분된다면 테스트 메서드도 구분하는 것이 유지보수에 유리하다.

```bash
@DisplayName("같은 ID가 없으면 가입에 성공하고 메일을 전송함")
@Test
void registerAndSendMail() {
	// 검증1 : 회원 데이터가 올바르게 저장되었는지 검증
	...
	// 검증2 : 이메일 발송을 요청했는지 검증
	...
	// 두개의 검증 대상을 분리하는게 좋다.
}

```

### 과도하게 구현 검증하지 않기

- 내부구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현보다 실행 결과를 검증해야 한다.
- 레거시 코드 같은 경우 테스트 코드를 작성할 때는 모의 객체를 많이 활용한다.

### 실행 환경이 다르다고 실패하지 않기

- 특정 OS에 종속되어 있는 테스트 코드를 작성하면 안된다.
- 간혹 특정 OS환경에서만 실행해야 하는 테스트는 @EnabledOnOs 애노테이션과 @DisabledOnOs 애노테이션을 사용해서 OS에 따른 테스트 실행 여부를 지정하면 된다

### 실행 시점이 다르다고 실패하지 않기

- now()와 같이 실행 시점에 따라 값이 다른 메서드  → mock, 특정 시점
- 실행 시점에 상관없이 결과가 동일하게 바꿔야 한다.

### 랜덤 하게 실패하지 않기

- 랜덤값에 따라 달라지는 결과를 검증할때 주로 이런 문제가 발생한다.
- 직접 랜덤값을 생성하지 말고 생성자를 통해 값을 받도록 수정하면 테스트가 가능
- 랜덤 값 생성을 다른 객체에 위임하게 바꿔도 된다.

### 필요하지 않은 값은 설정하지 않기

- 동일 ID가 존재하는 상황

```bash
// 1. 필요하지 않은 값까지 설정
Register reg = Register.build()
	.id("id")
	.name("name")
	.password("pw")
	.build();

// 2. 필요한 값만 설정
Register reg = Register.build()
	.id("id")
	.build();
```

### 조건부로 검증하지 않기

- 테스트는 성공하거나 실패해야 한다. 테스트가 성공하거나 실패하려면 반드시 단언을 실행해야 한다.
- 만약 조건에 따라서 단언을 하지 않으면 그 테스트는 성공하지도 실패하지도 않은 테스트가 된다.

### 통합 테스트는 필요하지 않은 범위까지 연동하지 않기

- 테스트 시간이  길어지는 것을 방지하기 위해 적절한 어노테이션으로 통합 테스트를 진행해야 한다.
- @JdbcTest → DataSource, JdbcTemplate만 초기화
- @SpringBootTest → 서비스, 컨트롤러 등 모든 스프링 빈을 초기화

### 더 이상 쓸모 없는 테스트 코드

- 단순히 특정 클래스의 사용법을 익히기 위해 작성한 테스트 코드를 유지할 필요는 없다.
- 단지 테스트 커버리지를 높이기 위한 목적으로 작성한 테스트 코드는 유지할 필요가 없다.