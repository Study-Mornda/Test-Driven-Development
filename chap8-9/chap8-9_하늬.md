# 8. 테스트 가능한 설계

## 테스트가 어려운 코드, 해결 방법

- 하드 코딩된 경로

    → 생성자, setter, 메서드 인자로 해당 값을 교체해준다.

- 의존 객체를 new로 직접 생성 (ex: dao를 위해 미리 테이블 생성이 필요할 수 있음)

    → 생성자, setter로 주입에서 대역을 사용할 수 있게 한다.

- 정적 메서드 사용

    → 외부 라이브러리는 직접 사용하지 말고 감싸서 사용하기

- 실행 시점에 따라 달라지는 결과

    → 시간, random 값 생성 기능 분리한다.

    → '임의의 날짜,시간대'가 필요하더라도 실제 코드에서 LocalDate#now 처럼 매번 다른 상황을 만들지 말고, 대역을 주입해서 **테스트 코드 상의** 시점을 만들면 테스트가 좀 더 안정적임

- 역할이 섞여 있는 코드 (ex: 대역 또는 실제 구현이 필요한 객체가 있어야 테스트 가능한 경우)

    → 테스트하고 싶은 코드를 분리한다.

- 그 외 테스트가 어려운 코드
    - 메서드 중간에 소켓 통신 코드가 섞여있음
    - 콘솔 I/O
    - 테스트 대상이 사용하는 의존 클래스, 메서드가 final (대역으로 대체 어려움)
    - 테스트 대상의 소스 소유x

---

# 9. 테스트 범위와 종류

## 테스트 범위

- 기능 테스트(E2E테스트) : 사용자 입장에서 시스템의 기능 동작 확인
    - 시스템의 모든 구성 요소 필요
    - QA가 주로 하는 테스트
    - 사용자 입장에서 테스트하므로 어떤 값이 삽입되면 DB에 직접 쿼리 날려 검증하지 않고 Admin 화면을 통해 확인하거나 관리 도구로 검증하는 식이다.
- 통합 테스트 : 시스템의 각 구성 요소가 올바르게 연동되는지 확인
    - 소프트웨어의 코드를 직접 테스트함
    - 웹앱에서 주로 프레임워크, 라이브러리, DB, 구현한 코드를 테스트함
- 단위 테스트 : 개별 코드나 컴포넌트가 기대한대로 동작하는지 확인한다.
    - 클래스, 메서드 범위를 테스트함
    - 일부 의존 대상은 스텁이나 모의 객체등의 대역으로 대체한다.

## 각 테스트 범위 간 차이

- 테스트 상황 구성 : 통합 테스트, 기능 테스트 > 단위 테스트(코드만 필요)
    - 통합 : DB, 캐시 서버 구성
    - 기능 : 웹 서버 구동, 앱 설치
- 테스트 실행 속도 : 기능 테스트 > 통합 테스트 > 단위 테스트(대역으로 처리)
    - 통합 : DB연결, 소켓 통신, 스프링 컨테이너 초기화
    - 기능 : 브라우저, 앱 구동

> 상황 준비, 결과 확인이 어려운 경우 단위 테스트와 대역의 조합으로 해결해야한다.

## 테스트를 자동화하는 시도가 증가하고있다.

- 기능 테스트 : E2E의 모든 상황이 갖춰줘야 하므로 자동화하기 가장 어렵다
    - 정상적인 경우, 몇 가지 특수한 상황만 테스트 범위로 잡는다.
- 통합 테스트 : 기능 테스트보다 제약이 덜 하다
    - 기능 테스트보다 실행 시간이 짧고, 상황을 유연하게 구성할 수 있다.
- 단위 테스트: 통합테스트로도 만들기 힘든 상황을 쉽게 구성할 수 있다.

> 더 많이 작성하는 순 : 기능 테스트 < 통합 테스트 < 단위 테스트

**단위 테스트→ 다양한 상황/ 통합,기능 테스트→ 주요 상황을 작성하는게 좋다.**

## 외부 연동이 필요한 테스트 예

### 1. 스프링 부트와 DB 통합 테스트(`@SpringBootTest`)

- 통합 테스트 : 실제로 DB 사용, 스프링 컨테이너 생성에 딜레이 생김
- 단위 테스트 : db 사용하는 대신 가짜 구현 사용( `MemoryUserRepository.java` )

### 2. WireMock을 이용한 REST 클라이언트 테스트

- 단위 테스트 : WireMock으로 서버 API를 스텁으로 대체

```java
@BeforeEach
void setUp() {
	wireMockServer = new WireMockServer(options().port(8089)); // 대역 생성
	wireMockServer.start(); // 대역 서버 실행
}

@AfterEach
void tearDown() {
	wireMockServer.stop();
}

@Test
void valid() {
	wireMockServer.stubFor(post(urlEqualTo("/card"))
	.withRequestBody(equalTo("1234567890"))          // 요청
	.willReturn(aRespose()                           // 응답 - 스텁으로 대체
		.withHeader("Content-TYpe", "test/plain")
		.withBody("ok")));
}
```

aResponse패키지:`import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;` 

### 3. 스프링 부트의 내장 서버를 이용한 API 기능 테스트

- 임의의 포트 사용

```java
@SpringBootTest(
	webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT
)
```

- `TestRestTemplate`사용 : 스프링 부트가 테스트 목적으로 제공. 내장 서버에 연결하는 RestTemplate이다