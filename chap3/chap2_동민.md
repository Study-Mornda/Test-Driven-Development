## 초반에 복잡한 테스트부터 시작하면 안된다.

- 초반에 복잡한 테스트로 추가하면 해당 테스트를 통과시키기 위해 한 번에 구현해야 할 코드가 많아진다.
- 한번에 많은 코드를 만들다 보면
    - 나도 모르게 버그를 만들고 나중에 버그를 잡기 위해 많은 시간을 허비하게 된다.
    - 테스트 통과 시간이 길어지고 집중력도 떨어져 흐름이 자주 끊기게 된다.

## 구현하기 쉬운 테스트부터 시작하기

가장 구현하기 쉬운 테스트는 아래와 같다.

- 모든 조건을 충족하는 경우 (STRONG 리턴)
- 모든 조건을 충족하지 않는 경우 (WEAK 리턴)

두가지 모두 그냥 해당 값을 리턴하면 된다. 그러면 다음 테스트로는 무엇을 골라야 할까?

- 모든 규칙을 충족하지 않는 경우 (모든 규칙을 검사하는 코드를 구현해야 함 따라서 구현해야 할 코드가 너무 많음)
- 한 규칙만 충족하는 경우 (한 규칙을 충족하는지 여부 검사 - WEAK 리턴)
- 두 규칙을 충족하는 경우 (충족하지 않는 규칙이 하나 존재 → NORMAL 리턴)

## 완급 조절

한 번에 얼마만큼의 코드를 작성할 것인가

1. 정해진 값을 리턴
2. 값 비교를 이용해서 정해진 값을 리턴
3. 다양한 테스트를 추가하면서 구현을 일반화

뻔한 구현이라도 위의 테스트-구현-확인이라는 리듬에 맞춰서 연습해야 한다.

## 지속적인 리펙토링

- TDD를 진행하는 과정에서 지속적으로 리펙토링을 진행하면 코드 가독성이 높아진다.
- 코드 가독성이 높아지면 개발자는 더욱 빠르게 코드를 분석할 수 있다.
- 코드 변경의 어려움을 줄여주고 향후 유지보수에 도움이 된다.
- 더 궁금하면 마틴 파울러의 리펙토링 참고

## 테스트 대상 코드의 리펙토링 시점

- 상수를 변수로 바꾸거나 변수 이름을 변경하는 것과 같은 작은 리펙토링을 바로바로 바꾼다.
- 메서드 추출이나 메서드의 구조에 영향을 주는 리펙토링은 큰 틀에서 구현 흐름이 눈에 들어오기 시작한 뒤에 진행한다.

구현 초기에는 메서드 추출과 같은 리펙토링을 진행하면 코드 구조를 잘못 잡을 가능성이 있다. 이럴때는 리팩토링을 되돌려 다음 테스트를 진행하고 그런뒤 코드의 의미나 구조가 더 명확해지면 그때 다시 리펙토링을 시도한다.

## 시작이 안 될땐 단언부터 고민

테스트 코드의 구조는 아래와 같다.

- given(준비) : 테스트에 필요한 데이터들을 세팅 단계
- when(실행) : 직접 실행하는 단계
- then(단언, 결과확인) : 단언문을 통해 결과를 유도 판단한는 단계

테스트 코드를 작성하다 보면 시작인 잘 안될때가 있는데 이때는 검증하는 코드부터 작성하기 시작하면 좋다.

```java
@Test
void test() {
	// given(준비)
	LocalDate expectDate;

	// when(실행)
	expectDate = cal.claculate(파라미터);

	// then(단언)
	assertEquals(LocalDate.of(2019,8,9), expectDate);
}
```

## 구현이 막히면

TDD를 진행하다 보면 구현이 막힐 때가 있는데 이때는 과감히 코드를 지우고 미련 없이 다시 시작한다. 다시 시작할 때에는 아래와 같은 순서로 한다.

- 쉬운 테스트, 예외적인 테스트
- 완급 조절